=pod

=head1 lorito opcode definitions

=begin verify_begin

=end verify_begin


=head2 Execution Ops


=head3 noop

=over

=item Registers

None

=item Description

Do nothing.  Waste a cycle.

=item Reason

Sometimes, you just need to be lazy.

=back



=head3 end

=over

=item Registers

None

=item Description

Stop the interperter, cleanly.

=item Reason

Although this could be dangerous, code should have the ablity to stop
execution.

=back



=head3 add

=over

=item Registers

$dest, $src1, $src2

=item Description

Add $src1 and $src2 and store result in $dest.

=item Reason

Math becomes very difficult without being able to add.

=back



=head3 sub

=over

=item Registers

$dest, $src1, $src2

=item Description

Subtract $src1 and $src2 and store result in $dest.

=item Reason

Likewise, subtraction is vital to quick and efficient math.

=back



=head3 mul

=over

=item Registers

$dest, $src1, $src2

=item Description

Multiply $src1 and $src2 and store the result into $dest

=item Reason

Making multiplication a addition loop is unadvisable, no matter how minimal
you're trying to be

=back



=head3 div

=over

=item Registers

$dest, $src1, $src2

=item Description

Divide $src1 by $src2 and store the result in $dest.  With the Int form, only
the quotient is stored in $dest.

=item Reason

A loop of subtractions would be possible to emulate a div, but that's kind
of silly.

=back



=head3 mod

=over

=item Registers

$dest, $src1, $src2

=item Description

Divide $src1 by $src2 and store the remainder in $dest.

=item Reason

It's up to debate to include this instead of forcing a divide, cast, multiply
and subtract.  The speed up given by this instruction over how often some
common problems need this operator outweighs reducing the operators by one.

=back



=head3 and

=over

=item Registers

$dest, $src1, $src2

=item Description

Performs a binary AND on $src1 and $src2.  The result is stored in $dest.

=item Reason

AND is a basic building block of all logic.  Not including this opcode would
needlessly complicate all logic.

=back



=head3 or

=over

=item Registers

$dest, $src1, $src2

=item Description

Perfoms a binary OR on $src1 and $src2.  The result is stored in $dest.

=item Reason

Just like AND, OR is a basic logic building block, removing it would be
burdensome to users.

=back



=head3 xor

=over

=item Registers

$dest, $src1, $src2

=item Description

Perfoms a binary XOR on $src1 and $src2.  The result is stored in $dest.

=item Reason

XOR is not as fundemental as AND and OR, but simplifies a lot of operations
that would otherwise be complicated and happen often and.

=back



=head3 not

=over

=item Registers

$dest, $src1

=item Description

Perfoms a binary NOT on $src1.  The result is stored in $dest.

=item Reason

NOT could be emulated with XOR, and in a fairly simple manner.  It would be
replaced by two operations instead of one, a load constant and an xor.

=back



=head3 shl

=over

=item Registers

$dest, $src1, $src2

=item Description

Shifts the bits in $src1 by $src2 bits to the left and stores the result in
$dest.

=back



=head3 shr

=over

=item Registers

$dest, $src1, $src2

=item Description

Shifts the bits in $src1 by $src2 bits to the right and stores the result in
$dest.

=back


=head2 Comparison Ops



=head3 iseq

=over

=item Registers

INT($dest), $src1, $src2

=item Description

This is the equals operator.  It takes $src1 and $src2 and checks if they are
equal and sets INT($dest) to 1 or 0, depending if they are equal or not.
For INT and NUM, it does a mathmatical equavalance.  For STR, it will return
1 if the two STRs are identical.  For PMC, the two PMCs must point to the
exact same PMC.

=item Reason

We could use a logical operator for the INT version of iseq, but that would not
work for NUM, STR and PMC.

=back



=head3 isgt

=over

=item Registers

INT($dest), $src1, $src2

=item Description

Comparse $src1 and $src2.  If $src1 is greater than $src2, it sets INT($dest)
to 1, otherwise it sets INT($dest) to 0.

=item Reason

This really has no alternative but to be included.  The less than version has
been left out since it can be reasonably done by simply reversing $src1 and
$src2.

=back



=head3 isge

=over

=item Registers

INT($dest), $src1, $src2

=item Description

This operator is identical to isgt, except it will also set INT($dest) to 1
if $src1 and $src2 are equal.

=item Reason

This might have been left out in favor of checking isgt and iseq.  But that
would be ineffecient compared to adding one more op to the group.

Just like isgt, isle is not included since it is easy to emulate by reversing
$src1 and $src2.

=back


=head2 Flow Control Ops



=head3 goto

=over

=item Registers

$imm

=item Description

Takes an $imm address and moves the program counter there.  Execution will
start there as the next instruction.

Note that this does not cross code block bounds.

=item Reason

The machine needs to be able to branch unconditionaly.  While it might be
possible to get away with only if, goto gives some optimzation possiblities.

=back



=head3 if

=over

=item Registers

$src1, $imm

=item Description

Checks $src1 to be 0.  If it is 0, the program counter is unchanged, otherwise
the program counter is changed to the value in $imm.

=item Reason

Without doing very complicated things with call, this is the only other way
to do conditional branching.  Therfore, it is extremely vital.

=back


=head2 Register Manipulation Ops


=head3 set



=head3 load_const

=over

=item Registers

$dest, INT($src1), INT($src2), $imm

=item Description

This operator will load data from the context data block into a register.
The data loaded will start at $src1+$imm and will read $src2 bytes and store
the results into $dest.

In the case that INT($src2) is 0, the "natural" length will be read.  For
STR, the number of bytes until the first null charecter that is found is used 
as the length.  For INT, the natueral length is 4 bytes, and NUM is 8 bytes.

=item Example

  $S1 = STR LOAD_CONST :[method_ok]

This will take the string starting at method_ok in the data block and read
the entire string until a null charecter or the end of the block into the
$S1 register.

  $I1 = INT LOAD_IMM :4;
  $I2 = INT LOAD_IMM :2;
  $I3 = INT LOAD_CONST $I1, $I2;

This will load the first two bytes ($I2) starting at the fourth byte ($I1)
of the data block and store the integer into $I3.

=item Reason

Loading constants from the data block is the only way that you can do useful
stuff with by any manner of effenceny.

However, this might be obsolete with a constant PMC that you can load from
the context.

=back

=head3 load_imm

=over

=item Registers

$dest, $imm

=item Description

Loads an immediate value from $imm into a register.  Because of the size of
$imm, the only registers you can load this way are INT types.

=item Example

  $I1 = INT LOAD_IMM :4;

Loads the number 4 into the register $I1.

=item Reason

Without the ablity to have and load immediate values, loading data into
registers becomes cumbersome, difficult and complex.

=back

=head3 coerce_int

=over

=item Registers

$dest, INT($src1)

=item Description

Convert the int in $src1 into the form of $dest and stores the result into
$dest.

=item Example

  $P1 = PMC COERCE_INT $I1;

$P1 will contain a boxed integer.

=item Reason

This is the basic form of integer casting.  In order to load data from another
type, some kind of basic casting is required.  Without this, there would be
no way to do any kind of casting.

=back



=head3 coerce_num

=over

=item Registers

$dest, NUM($src1)

=item Description

Convert the floating point number  in $src1 into the form of $dest and stores 
the result into $dest.

=item Example

  $S1 = STR COERCE_NUM $N1;

$N1 will contain string version of $N1.

=item Reason

Just like the integer casting, we need a way to cast from an integer to any
other type.

=back



=head3 coerce_str

=over

=item Registers

$dest, STR($src1)

=item Description

Convert the string in $src1 into the form of $dest and stores the result into 
$dest.

=item Example

  $I1 = NUM COERCE_STR $S1;

$I1 will contain the integer version of $S1.

=back

=head2 PMC Ops



=head3 new

=over

=item Registers

PMC($dest), $src1, $imm

=item Description

This creates a new PMC.  The operation of creating the PMC depends on the 
type of $src1:

=over

=item INT

This will create a blank PMC of size $src1+$imm.  All other details need
to be taken care of manually.

=item PMC

This will create an identically sized PMC as $src1.  The lookup and vtable
PMCs are copied over, but the data from $src1 is not.

=back

=back



=head3 store



=head3 load



=head3 push_arg



=head3 pop_arg



=head3 cnt_arg



=head3 call



=head3 push_ret



=head3 pop_ret



=head3 cnt_ret



=head3 lookup



=head3 ctx



=head3 new_ctx



=head3 block


=head2 Environment Ops



=head3 loadlib



=head3 read



=head3 write



=head3 say



=head3 gripe


=head2 These Ops



=head3 hcf

=over

=item Registers

None

=item Description

Halt, and Catch any instance of skynet on Fire.

=item Reason

Just in case.

=back

=begin verify_end

=end verify_end
